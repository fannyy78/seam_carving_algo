double right = (prev_col < ncols - 1) ? energy_mat(i, prev_col + 1) : INFINITY;
double min_val = std::min({left, up, right});
if (min_val == left) {
seam(i) = prev_col - 1;
} else if (min_val == right) {
seam(i) = prev_col + 1;
} else {
seam(i) = prev_col;
}
}
return seam;
}')
cppFunction('
NumericMatrix remove_vertical_seam_cpp(NumericMatrix im, NumericVector seam) {
int nrows = im.nrow();
int ncols = im.ncol();
NumericMatrix new_im(nrows - 1, ncols);
for (int i = 0; i < ncols; i++) {
int col_to_remove = seam(i);
for (int j = 0; j < nrows; j++) {
if (j < col_to_remove) {
new_im(j, i) = im(j, i);
} else if (j > col_to_remove) {
new_im(j - 1, i) = im(j, i);
}
}
}
return new_im;
}')
seam_carving_cpp <- function(im, n_seams) {
gray <- grayscale(im)
# Conversion en matrice
gray_matrix <- as.matrix(gray)
for (step in 1:n_seams) {
cat("Suppression seam", step, "\n")
# Calcul de l'énergie
energy <- compute_energy_cpp(gray_matrix)
# Recherche de la meilleure couture
seam_energies <- numeric(ncol(energy))
all_seams <- list()
for (col in 1:ncol(energy)) {
all_seams[[col]] <- trace_seam_cpp(energy, col - 1)
}
# Calcul de l'énergie de chaque couture
for (i in 1:ncol(energy)) {
seam_energies[i] <- sum(energy[cbind(1:nrow(energy), as.integer(all_seams[[i]]) + 1)])
}
# Sélectionner la meilleure couture
best_idx <- which.min(seam_energies)
best_seam <- all_seams[[best_idx]]
# Suppression de la couture
gray_matrix <- remove_vertical_seam_cpp(gray_matrix, best_seam)
}
return(as.cimg(gray_matrix))
}
# Test de l'algorithme optimisé avec Rcpp
im_reduite_cpp <- seam_carving_cpp(im, n_seams)
# Affichage des résultats
par(mfrow = c(1, 2))
plot(im, main = "Image originale")
plot(im_reduite_cpp, main = paste("Image réduite avec C++ (", n_seams, "seams)", sep = ""))
# Test de l'algorithme optimisé avec Rcpp
im_reduite_cpp <- seam_carving_cpp(im, n_seams)
# Affichage des résultats
par(mfrow = c(1, 2))
plot(im, main = "Image originale")
plot(im_reduite_cpp, main = paste("Image réduite avec C++ (", n_seams, "seams)", sep = ""))
#include <Rcpp.h>
using namespace Rcpp;
im_reduite <- greedy_carving_cpp(im, 30)
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)
library(imager)
library(ggplot2)
library(microbenchmark)
library(M2algorithmique)
library(Rcpp)
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)
library(imager)
library(ggplot2)
library(microbenchmark)
library(M2algorithmique)
library(Rcpp)
im <- load.example("parrots")
plot(im, main = "Image originale")
n_seams = 50
im_reduite <- reduce_image_seams(im, n_seams)
plot(im_reduite)
im_reduite <- greedy_carving_cpp(im, n_seams)
im_reduite <- greedy_carving_cpp(im, n_seams)
devtools::document()
devtools::load_all()
tools::showNonASCIIfile("R/image_reduction.R")
im_reduite <- greedy_carving_cpp(im, n_seams)
plot(im_reduite)
# Charger une image d'exemple
im <- load.example("parrots")
# Mesurer le temps d'exécution de l'algorithme naïf en R
system.time({
im_reduite_r <- seam_carving(im, n_seams = 50)
})
# Mesurer le temps d'exécution de l'algorithme optimisé en C++
system.time({
im_reduite_cpp <- seam_carving_cpp(im, n_seams = 50)
})
# Affichage des résultats
par(mfrow = c(1, 2))
plot(im, main = "Image originale")
plot(im_reduite_r, main = "Image réduite (R)")
plot(im_reduite_cpp, main = "Image réduite (C++)")
#' Calcul de l'energie dynamique d'une image
#'
#' @param gray_img Image en niveaux de gris (cimg)
#' @return Image d'energie (cimg)
#' @export
compute_dynamic_energy <- function(gray_img) {
gx <- imgradient(gray_img, "x")  # Gradient de l'image dans la direction x
gy <- imgradient(gray_img, "y")  # Gradient de l'image dans la direction y
energy <- sqrt(gx^2 + gy^2)     # L'énergie est la somme des carrés des gradients dans x et y
return(energy)
}
#' Calcule la matrice cumulative d'energie dynamique
#'
#' @param energy_mat Matrice d'energie (h x w)
#' @return Matrice cumulative (h x w)
#' @export
cumulative_dynamic_energy <- function(energy_mat) {
h <- nrow(energy_mat)  # Hauteur de l'image
w <- ncol(energy_mat)  # Largeur de l'image
cum_energy <- energy_mat  # Initialiser la matrice cumulative avec l'énergie initiale
# Calcul de l'énergie cumulative
for (i in 2:h) {
for (j in 1:w) {
left   <- if (j > 1) cum_energy[i - 1, j - 1] else Inf  # Cumul gauche
middle <- cum_energy[i - 1, j]  # Cumul du milieu
right  <- if (j < w) cum_energy[i - 1, j + 1] else Inf  # Cumul droit
cum_energy[i, j] <- energy_mat[i, j] + min(left, middle, right)  # Ajouter l'énergie du pixel à l'énergie minimale du voisinage
}
}
return(cum_energy)  # Retourner la matrice d'énergie cumulative
}
#' Retrouve la seam minimale dynamique
#'
#' @param cum_energy Matrice cumulative d'energie (h x w)
#' @return Vecteur (longueur h) representant la seam
#' @export
find_dynamic_seam <- function(cum_energy) {
h <- nrow(cum_energy)  # Hauteur de l'image
w <- ncol(cum_energy)  # Largeur de l'image
seam <- integer(h)  # Vecteur pour stocker les indices de la seam
seam[h] <- which.min(cum_energy[h, ])  # Trouver la colonne avec l'énergie minimale dans la dernière ligne
# Remonter à partir de la dernière ligne pour retrouver la seam optimale
for (i in (h - 1):1) {
prev_col <- seam[i + 1]  # Récupérer la colonne de la ligne précédente
options <- c(
if (prev_col > 1) cum_energy[i, prev_col - 1] else Inf,  # Option gauche
cum_energy[i, prev_col],  # Option centrale
if (prev_col < w) cum_energy[i, prev_col + 1] else Inf   # Option droite
)
offset <- which.min(options) - 2  # Choisir l'option avec l'énergie minimale
seam[i] <- prev_col + offset  # Mettre à jour la colonne de la seam
}
return(seam)  # Retourner la seam trouvée
}
#' Supprime une couture verticale dynamique
#'
#' @param im Image (objet `cimg`)
#' @param seam Vecteur des indices de colonnes a supprimer
#' @return Image modifiee (objet `cimg`)
#' @export
remove_dynamic_vertical_seam <- function(im, seam) {
im_array <- as.array(im)  # Convertir l'image en tableau
w <- dim(im_array)[1]  # Largeur de l'image
h <- dim(im_array)[2]  # Hauteur de l'image
c <- dim(im_array)[4]  # Nombre de canaux (couleurs)
new_array <- array(0, dim = c(w - 1, h, 1, c))  # Créer un nouveau tableau pour l'image modifiée
# Supprimer la colonne correspondant à la seam
for (y in 1:h) {
col <- seam[y]  # Récupérer l'indice de la colonne à supprimer
keep_cols <- setdiff(1:w, col)  # Trouver les colonnes à garder
for (ch in 1:c) {
new_array[, y, 1, ch] <- im_array[keep_cols, y, 1, ch]  # Copier les pixels restants
}
}
return(as.cimg(new_array))  # Retourner l'image modifiée
}
#' Reduction d'image par seam carving dynamique
#'
#' @param im Image a reduire (objet `cimg`)
#' @param n_seams Nombre de coutures a supprimer
#'
#' @return Image reduite (objet `cimg`)
#' @export
reduce_dynamic_image_seams <- function(im, n_seams) {
par(mfrow = c(1, 2))  # Affichage avant/apres
plot(im, main = "Image originale")
for (i in 1:n_seams) {
cat("Suppression seam dynamique", i, "\n")
gray <- grayscale(im)  # Convertir l'image en niveaux de gris
energy <- compute_dynamic_energy(gray)  # Calculer l'énergie
energy_mat <- t(as.matrix(energy))  # Convertir l'énergie en matrice
cum_energy <- cumulative_dynamic_energy(energy_mat)  # Calculer l'énergie cumulative
best_seam <- find_dynamic_seam(cum_energy)  # Trouver la seam minimale
im <- remove_dynamic_vertical_seam(im, best_seam)  # Supprimer la seam
}
plot(im, main = paste("Image apres reduction -", n_seams, "seams supprimees"))
return(im)  # Retourner l'image réduite
}
im_reduite <- seam_carving_dp(im, 100)
im_reduite_dp <- seam_carving_dp(im, 100)
plot(im_reduite_dp)
im_reduite_dp <- seam_carving_dp(im, n_seams)
plot(im_reduite_dp)
im_reduite <- reduce_dynamic_image_seams(im, n_seams)
im_reduite <- seam_carving_dp(im, n_seams)
plot(im_reduite, main = "Image réduite (Programmation Dynamique C++)")
im_reduite <- reduce_image_seams(im, n_seams)
plot(im_reduite)
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)
library(imager)
library(ggplot2)
library(microbenchmark)
library(M2algorithmique)
library(Rcpp)
dim(im)
# Simuler des tailles d'images et mesurer le temps d'exécution pour chaque taille
sizes <- c(100, 200, 300, 400, 500)
times <- sapply(sizes, function(size) {
im <- load.example("parrots")
reduce_image_seams(im, n_seams = 50)  # Changez l'image en fonction de la taille
})
library(microbenchmark)
# Simulation des tailles d'images et mesure du temps pour chaque taille
sizes <- c(100, 200, 300, 400, 500)
times_naive <- sapply(sizes, function(size) {
im <- load.example("parrots")
im_resized <- resize(im, size, size)  # Redimensionner l'image à la taille spécifiée
system.time(reduce_image_seams(im_resized, n_seams = 50))["elapsed"]
})
times_dynamic <- sapply(sizes, function(size) {
im <- load.example("parrots")
im_resized <- resize(im, size, size)  # Redimensionner l'image à la taille spécifiée
system.time(reduce_image_seams_dynamic(im_resized, n_seams = 50))["elapsed"]
})
# Charger l'exemple d'image
im <- load.example("parrots")
# Fonction pour mesurer les temps d'exécution pour l'algorithme naïf en R
measure_naive_R <- function(im, n_seams) {
start_time <- Sys.time()
im_reduite <- reduce_image_seams(im, n_seams)
end_time <- Sys.time()
return(as.numeric(difftime(end_time, start_time, units = "secs")))
}
# Fonction pour mesurer les temps d'exécution pour l'algorithme naïf en C++
measure_naive_CPP <- function(im, n_seams) {
start_time <- Sys.time()
im_reduite <- greedy_carving_cpp(im, n_seams)
end_time <- Sys.time()
return(as.numeric(difftime(end_time, start_time, units = "secs")))
}
# Fonction pour mesurer les temps d'exécution pour l'algorithme dynamique en R
measure_dynamic_R <- function(im, n_seams) {
start_time <- Sys.time()
im_reduite <- reduce_dynamic_image_seams(im, n_seams)
end_time <- Sys.time()
return(as.numeric(difftime(end_time, start_time, units = "secs")))
}
# Fonction pour mesurer les temps d'exécution pour l'algorithme dynamique en C++
measure_dynamic_CPP <- function(im, n_seams) {
start_time <- Sys.time()
im_reduite <- seam_carving_dp(im, n_seams)
end_time <- Sys.time()
return(as.numeric(difftime(end_time, start_time, units = "secs")))
}
# Simulation des tailles d'image
sizes <- c(100, 200, 300, 400, 500)
# Mesurer les temps d'exécution pour les algorithmes naïf et dynamique en R et C++
times_naive_R <- sapply(sizes, function(size) measure_naive_R(im, size))
times_naive_CPP <- sapply(sizes, function(size) measure_naive_CPP(im, size))
ss
s
# Charger l'exemple d'image
im <- load.example("parrots")
# Fonction pour mesurer les temps d'exécution pour l'algorithme naïf en R
measure_naive_R <- function(im, n_seams) {
start_time <- Sys.time()
im_reduite <- reduce_image_seams(im, n_seams)
end_time <- Sys.time()
return(as.numeric(difftime(end_time, start_time, units = "secs")))
}
# Fonction pour mesurer les temps d'exécution pour l'algorithme naïf en C++
measure_naive_CPP <- function(im, n_seams) {
start_time <- Sys.time()
im_reduite <- greedy_carving_cpp(im, n_seams)
end_time <- Sys.time()
return(as.numeric(difftime(end_time, start_time, units = "secs")))
}
# Fonction pour mesurer les temps d'exécution pour l'algorithme dynamique en R
measure_dynamic_R <- function(im, n_seams) {
start_time <- Sys.time()
im_reduite <- reduce_dynamic_image_seams(im, n_seams)
end_time <- Sys.time()
return(as.numeric(difftime(end_time, start_time, units = "secs")))
}
# Fonction pour mesurer les temps d'exécution pour l'algorithme dynamique en C++
measure_dynamic_CPP <- function(im, n_seams) {
start_time <- Sys.time()
im_reduite <- seam_carving_dp(im, n_seams)
end_time <- Sys.time()
return(as.numeric(difftime(end_time, start_time, units = "secs")))
}
# Simulation des tailles d'image
sizes <- c(100, 200, 300, 400, 500)
# Fixer un nombre de seams constant pour toutes les méthodes
n_seams <- 100
# Mesurer les temps d'exécution pour les algorithmes naïf et dynamique en R et C++
times_naive_R <- sapply(sizes, function(size) measure_naive_R(im, n_seams))
times_naive_CPP <- sapply(sizes, function(size) measure_naive_CPP(im, n_seams))
s
s
# Charger l'exemple d'image
im <- load.example("parrots")
# Fonction pour mesurer les temps d'exécution pour l'algorithme naïf en R
measure_naive_R <- function(im, n_seams) {
start_time <- Sys.time()
im_reduite <- reduce_image_seams(im, n_seams)
end_time <- Sys.time()
return(as.numeric(difftime(end_time, start_time, units = "secs")))
}
# Fonction pour mesurer les temps d'exécution pour l'algorithme naïf en C++
measure_naive_CPP <- function(im, n_seams) {
start_time <- Sys.time()
im_reduite <- greedy_carving_cpp(im, n_seams)
end_time <- Sys.time()
return(as.numeric(difftime(end_time, start_time, units = "secs")))
}
# Fonction pour mesurer les temps d'exécution pour l'algorithme dynamique en R
measure_dynamic_R <- function(im, n_seams) {
start_time <- Sys.time()
im_reduite <- reduce_dynamic_image_seams(im, n_seams)
end_time <- Sys.time()
return(as.numeric(difftime(end_time, start_time, units = "secs")))
}
# Fonction pour mesurer les temps d'exécution pour l'algorithme dynamique en C++
measure_dynamic_CPP <- function(im, n_seams) {
start_time <- Sys.time()
im_reduite <- seam_carving_dp(im, n_seams)
end_time <- Sys.time()
return(as.numeric(difftime(end_time, start_time, units = "secs")))
}
# Simulation des tailles d'image
sizes <- c(100, 200, 300, 400, 500)
# Fixer un nombre de seams constant pour toutes les méthodes
n_seams <- 20
# Mesurer les temps d'exécution pour les algorithmes naïf et dynamique en R et C++
times_naive_R <- sapply(sizes, function(size) measure_naive_R(im, n_seams))
times_naive_CPP <- sapply(sizes, function(size) measure_naive_CPP(im, n_seams))
times_dynamic_R <- sapply(sizes, function(size) measure_dynamic_R(im, n_seams))
times_dynamic_CPP <- sapply(sizes, function(size) measure_dynamic_CPP(im, n_seams))
# Régression linéaire pour comparer les temps d'exécution pour l'algorithme naïf en R
model_naive_R <- lm(times_naive_R ~ sizes)
summary(model_naive_R)
# Régression linéaire pour comparer les temps d'exécution pour l'algorithme naïf en C++
model_naive_CPP <- lm(times_naive_CPP ~ sizes)
summary(model_naive_CPP)
# Régression linéaire pour comparer les temps d'exécution pour l'algorithme dynamique en R
model_dynamic_R <- lm(times_dynamic_R ~ sizes)
summary(model_dynamic_R)
# Régression linéaire pour comparer les temps d'exécution pour l'algorithme dynamique en C++
model_dynamic_CPP <- lm(times_dynamic_CPP ~ sizes)
summary(model_dynamic_CPP)
# Comparaison des temps en graphiques
par(mfrow = c(2, 2))
plot(sizes, times_naive_R, main = "Naïf R", xlab = "Taille de l'image", ylab = "Temps (s)", type = "b")
plot(sizes, times_naive_CPP, main = "Naïf C++", xlab = "Taille de l'image", ylab = "Temps (s)", type = "b")
plot(sizes, times_dynamic_R, main = "Dynamique R", xlab = "Taille de l'image", ylab = "Temps (s)", type = "b")
plot(sizes, times_dynamic_CPP, main = "Dynamique C++", xlab = "Taille de l'image", ylab = "Temps (s)", type = "b")
# Charger l'image d'exemple
im <- load.example("parrots")
# Fonction pour mesurer les temps d'exécution pour l'algorithme naïf en R
measure_naive_R <- function(im, n_seams) {
start_time <- Sys.time()
im_reduite <- reduce_image_seams(im, n_seams)  # Fonction fictive pour l'algorithme naïf
end_time <- Sys.time()
return(as.numeric(difftime(end_time, start_time, units = "secs")))
}
# Fonction pour mesurer les temps d'exécution pour l'algorithme dynamique en R
measure_dynamic_R <- function(im, n_seams) {
start_time <- Sys.time()
im_reduite <- reduce_dynamic_image_seams(im, n_seams)  # Fonction fictive pour l'algorithme dynamique
end_time <- Sys.time()
return(as.numeric(difftime(end_time, start_time, units = "secs")))
}
# Simulation des tailles d'image
sizes <- c(100, 200, 300, 400, 500)
# Fixer un nombre de seams constant pour toutes les méthodes
n_seams <- 20
# Mesurer les temps d'exécution pour les algorithmes naïf et dynamique en R
times_naive_R <- sapply(sizes, function(size) measure_naive_R(im, n_seams))
times_dynamic_R <- sapply(sizes, function(size) measure_dynamic_R(im, n_seams))
# Afficher les résultats
print(times_naive_R)
print(times_dynamic_R)
#' Visualise une seam sur l'image
#'
#' @param im Image originale (objet `cimg`)
#' @param seam Vecteur des indices de colonnes de la seam
#' @return Image avec la seam visualisée en rouge
#' @export
visualize_seam <- function(im, seam) {
# Convertir l'image en tableau pour manipulation
im_array <- as.array(im)
h <- dim(im_array)[2]
w <- dim(im_array)[1]
# Créer une copie de l'image pour la visualisation
vis_array <- im_array
# Superposer la seam en rouge
for (y in 1:h) {
col <- seam[y]
# Remplacer le pixel par du rouge (R=255, G=0, B=0)
vis_array[col, y, 1, 1] <- 255  # Canal rouge
vis_array[col, y, 1, 2] <- 0    # Canal vert
vis_array[col, y, 1, 3] <- 0    # Canal bleu
}
# Convertir le tableau modifié en objet `cimg`
return(as.cimg(vis_array))
}
# Exemple d'utilisation
im <- load.image("path_to_your_image.jpg")  # Chargez votre image ici
gray <- grayscale(im)
energy <- compute_dynamic_energy(gray)
energy_mat <- t(as.matrix(energy))
cum_energy <- cumulative_dynamic_energy(energy_mat)
best_seam <- find_dynamic_seam(cum_energy)
# Visualiser la seam sur l'image
im_with_seam <- visualize_seam(im, best_seam)
plot(im_with_seam, main = "Image avec la seam en rouge")
for (ch in 1:c) {
new_array[, y, 1, ch] <- im_array[keep_cols, y, 1, ch]
}
gray <- grayscale(im)
energy <- compute_dynamic_energy(gray)
energy_mat <- t(as.matrix(energy))
cum_energy <- cumulative_dynamic_energy(energy_mat)
best_seam <- find_dynamic_seam(cum_energy)
# Visualiser la seam sur l'image
im_with_seam <- visualize_seam(im, best_seam)
plot(im_with_seam, main = "Image avec la seam en rouge")
#' Visualise une seam sur la carte d'énergie
#'
#' @param energy_mat Matrice d'énergie (h x w)
#' @param seam Vecteur des indices de colonnes de la seam
#' @return Image avec la seam visualisée en rouge sur la carte d'énergie
#' @export
visualize_seam_on_energy <- function(energy_mat, seam) {
h <- nrow(energy_mat)
w <- ncol(energy_mat)
# Créer une copie de la matrice d'énergie pour la visualisation
vis_energy <- energy_mat
# Superposer la seam en rouge
for (y in 1:h) {
col <- seam[y]
# Remplacer le pixel par une valeur élevée pour le rendre visible en rouge
vis_energy[y, col] <- max(energy_mat) + 100  # Une valeur élevée pour la visualisation
}
# Convertir la matrice modifiée en objet `cimg`
return(as.cimg(t(vis_energy)))
}
# Exemple d'utilisation
gray <- grayscale(im)
energy <- compute_dynamic_energy(gray)
energy_mat <- t(as.matrix(energy))
cum_energy <- cumulative_dynamic_energy(energy_mat)
best_seam <- find_dynamic_seam(cum_energy)
# Visualiser la seam sur la carte d'énergie
energy_with_seam <- visualize_seam_on_energy(energy_mat, best_seam)
plot(energy_with_seam, main = "Carte d'énergie avec la seam en rouge")
#' Visualise une seam sur l'image originale en utilisant la carte d'énergie
#'
#' @param im Image originale (objet `cimg`)
#' @param seam Vecteur des indices de colonnes de la seam
#' @return Image avec la seam visualisée en rouge
#' @export
visualize_seam_on_image <- function(im, seam) {
# Convertir l'image en tableau pour manipulation
im_array <- as.array(im)
h <- dim(im_array)[2]
w <- dim(im_array)[1]
c <- dim(im_array)[4]
# Créer une copie de l'image pour la visualisation
vis_array <- im_array
# Superposer la seam en rouge
for (y in 1:h) {
col <- seam[y]
# Remplacer le pixel par du rouge (R=255, G=0, B=0)
vis_array[col, y, 1, 1] <- 255  # Canal rouge
if (c > 1) {
vis_array[col, y, 1, 2] <- 0    # Canal vert (si l'image est en couleur)
vis_array[col, y, 1, 3] <- 0    # Canal bleu (si l'image est en couleur)
}
}
# Convertir le tableau modifié en objet `cimg`
return(as.cimg(vis_array))
}
# Exemple d'utilisation
gray <- grayscale(im)
energy <- compute_dynamic_energy(gray)
energy_mat <- t(as.matrix(energy))
cum_energy <- cumulative_dynamic_energy(energy_mat)
best_seam <- find_dynamic_seam(cum_energy)
# Visualiser la seam sur l'image originale
im_with_seam <- visualize_seam_on_image(im, best_seam)
plot(im_with_seam, main = "Image avec la seam en rouge")
